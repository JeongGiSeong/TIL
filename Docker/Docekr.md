도커: 컨테이너 기반 가상화 도구

가상화가 필요한 이유: 서버의 성능을 나눠서 사용할 수 있음. 하나의 서버 자원을 나눠 가지고 성능을 분산시키고, 분산된 서버는 각기 다른 서비스를 수행할 수 있음. 
                    -> 사용자가 많은 서비스는 더 많은 자원 할당 가능
가상화의 종류: 1. 서버 가상화: 하나의 물리적 서버 호스트에서 여러 개의 서버 운영 체제를 게스트로 실행할 수 있게 해주는 아키텍쳐. ex)하이퍼바이저. 가상머신 단위로 구별
                              각 가상머신엔 여러 운영체제가 설치되고, 하이퍼바이저에 의해 생성된 각각 운영체제를 게스트 운영체제라고 부름.
                              하이퍼바이저의 역할: OS에게 자원을 나눠주며 조율, OS의 커널을 번역해서 하드웨어에 전달
                              대표적인 가상화 툴로 VirtualBox, VMware 등이 있다.
                              단점: 가상화 작업은 반드시 하이퍼바이저를 거쳐야 함 -> 성능 손실. 게스트 OS를 운영하기 위한 라이브러리, 커널을 전부 포함하기 때문에 이미지로 만들었을때 너무 커짐

              2. 컨테이너 기반 가상화: 가상화 공간을 생성하기 위해 chroot, 네임스페이스, cgroup을 사용 -> 리눅스 자체 기능
                                      컨테이너 안에는 앱 구동을 위한 라이브러리, 실행 파일만 존재 -> 가상머신에 비해 이미지 용량 작음. 이미지 생성도 빠르고, 성능 손실도 거의 없음
                                      컨테이너 기술은 Docker만 사용하는 것이 아님

컨테이너란(기술적)? 이미지 목적에 따라 생성되는 프로세스 단위의 격리 환경. 프로세스의 생명 주기를 관리함.
                  Springboot 앱을 그냥 실행하나, 컨테이너로 실행하나 호스트 입장에선 그냥 하나의 프로세스로 보임.
컨테이너를 왜 써야하나? 컨테이너에 어떤 설정을 하든 HOST와 격리를 통해 독립된 개발 환경 보장. 프로세스를 컨테이너 단위로 사용하기 때문에 프로레스의 관리, 확장에 용이
컨테이너 관리: DOcker 엔진을 통해 관리: 유저가 컨테이너를 쉽게 쓸 수 있게 해주는 주체. 컨테이너/이미지/볼륨/네트워크 관리.

도커 엔진에서 명령어를 쳤을 때 발생하는 일: 1. docker run ~
                                          2. 도커 클라이어언트가 /var/run/docker.sock에 위치한 유닉스 소켓을 통해 도커 데몬 API 호출
                                          3. 도커 데몬은 명령어에 해당하는 작업을 수행하고 수행 결과를 도커 클라이언트에게 반환. 사용자에게 결과 출력
                                          도커 데몬(dockerd)는 컨테이너를 생성하고 실행하며 이미지를 관리하는 주체. 도커 프로레스가 실행되어 입력을 받을 준비가 된 상태를 도커 데몬이라고 함

자원 확장법: 1. Scale UP: 더 좋은 서버를 산다(4 -> 8)
            2. Scale out: 여러 대의 서버를 클러스터로 만들어 병렬로 확장(4 -> 4+4)
클러스터: 각기 다른 서버를 하나로 묶어 하나의 시스템같이 동작하게 하는 것. 동일한 네트워크를 사용하며 요청에 따라 트래픽 분산 가능
          단점: 도입의 어려움. 스케줄러, 로드밸런서, 고가용성 보장 등 처리해야 할 작업이 많음 -> 오픈소스를 사용해서 해결 ex)도커스웜
도커스웜: 
